/*
 * ssd1305_i2c.c
 *
 *  Created on: Aug 21, 2022
 *      Author: romte
 */

#include "ssd1305_i2c.h"
//#include "ssd1305_splash.h"
#include "i2c.h"

uint8_t page_offset = 0;
uint8_t column_offset = 0;

uint8_t picture[]=
{/*--  ������һ��ͼ��E:\��ʾ��ͼƬ\ER-OLED023-1.bmp  --*/
/*--  ����x�߶�=128x32  --*/
0xFF,0x01,0x01,0xFD,0x25,0x25,0x25,0x25,0x01,0xE1,0x59,0x45,0x59,0xE1,0x01,0x99,
0x25,0x25,0xC9,0x01,0x05,0x05,0xFD,0x05,0x05,0x01,0xFD,0x25,0x25,0x65,0x99,0x01,
0x01,0xFD,0x01,0x01,0x99,0x25,0x25,0xC9,0x01,0x01,0xFD,0x01,0x01,0xFD,0x19,0x21,
0xC1,0xFD,0x01,0x01,0xF9,0x05,0x05,0x25,0xE9,0x01,0x01,0x01,0x01,0x05,0x05,0xFD,
0x05,0x05,0x01,0xFD,0x25,0x25,0x25,0x25,0x01,0xF9,0x05,0x05,0x05,0x89,0x01,0x01,
0xFD,0x21,0x21,0x21,0xFD,0x01,0x01,0x01,0x01,0x01,0xF9,0x05,0x05,0x05,0x89,0x01,
0x01,0xF9,0x05,0x05,0x05,0xF9,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0xFD,0x01,
0x01,0x01,0x05,0x05,0xFD,0x05,0x05,0x01,0xFD,0x05,0x05,0x05,0xF9,0x01,0x01,0xFF,
0xFF,0x00,0x00,0x01,0x01,0x01,0x01,0x01,0x01,0x00,0x00,0x00,0x00,0x00,0x01,0x00,
0x01,0x01,0x00,0x00,0x00,0x00,0x01,0xF0,0xF0,0x90,0x91,0x90,0x00,0xF0,0xF1,0x10,
0x10,0xF1,0xE0,0x00,0x00,0x01,0x01,0x00,0xC0,0xE0,0x31,0x10,0x30,0xE1,0xC0,0x00,
0xF0,0xF1,0x00,0x00,0x00,0x01,0x01,0xF1,0xF0,0x90,0x90,0x90,0x00,0xF0,0xF0,0x11,
0x10,0xF0,0xE0,0x01,0xE1,0xF1,0x11,0xF1,0xE0,0x00,0x21,0x31,0x11,0xF0,0xE0,0x00,
0x21,0x30,0x90,0xF0,0x61,0x00,0x00,0x01,0x00,0x00,0xC0,0x61,0xF1,0xF1,0x00,0x00,
0x00,0x00,0x01,0x01,0x01,0x00,0x00,0x00,0x01,0x00,0x00,0x03,0x00,0x00,0x01,0x01,
0x01,0x01,0x00,0x00,0x01,0x00,0x00,0x00,0x01,0x01,0x01,0x01,0x00,0x00,0x00,0xFF,
0xFF,0x00,0x00,0x00,0x00,0x80,0xC0,0xC0,0x00,0x00,0x80,0xC0,0x40,0xC0,0x80,0x00,
0x80,0xC0,0x40,0xC0,0x80,0x00,0x80,0xCF,0x8F,0x08,0x88,0xC8,0x40,0xCF,0x8F,0x01,
0x83,0xC7,0x4C,0xC8,0x82,0x02,0x02,0x00,0x03,0x07,0x0C,0x08,0x0C,0xC7,0xC3,0x00,
0x0F,0x0F,0x08,0x08,0x08,0x08,0x00,0x8F,0xCF,0x08,0x08,0x08,0x00,0x0F,0x0F,0x08,
0x08,0x0F,0x07,0x00,0x07,0x0F,0x08,0x0F,0x07,0x00,0x0C,0x8E,0xCB,0x49,0xC8,0x80,
0x04,0x0C,0x08,0x0F,0x87,0xC0,0x42,0xC2,0x82,0x00,0x40,0x40,0x0F,0x0F,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xC0,0xC0,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,
0xFF,0x80,0x80,0x80,0x83,0x81,0xBF,0xBF,0x80,0x80,0xB0,0xB8,0xAC,0xA7,0xA3,0x80,
0x9D,0xBF,0xA2,0xBF,0x9D,0x80,0x82,0x81,0x82,0x80,0x90,0xB0,0xA2,0xBF,0x9D,0x80,
0xB0,0xB8,0xAC,0xA7,0xA3,0x80,0x80,0x80,0x80,0x9E,0xBF,0xA1,0xA1,0xBF,0xBF,0x80,
0x9E,0xBF,0xA1,0xA1,0xBF,0x9E,0x81,0x9F,0xBF,0xA1,0x80,0x96,0xB7,0xAD,0xAD,0xBB,
0x9A,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0xB0,0xB8,0xAC,0xA7,0xA3,
0x80,0xB0,0xB0,0x80,0x90,0xB0,0xA2,0xBF,0x9D,0x80,0xBF,0xBF,0x80,0xBF,0xBF,0x81,
0x81,0xBF,0xBE,0x80,0x9E,0xBF,0xA1,0xB3,0x92,0x80,0xBF,0xBF,0x81,0x81,0xBF,0xBE,
0x80,0x9E,0xBF,0xA5,0xA5,0xB7,0x96,0x80,0x96,0xB7,0xAD,0xAD,0xBB,0x9A,0x80,0xFF
};


void oled_command(uint8_t cmd) {
	uint8_t tmpcmd = cmd;
	uint8_t ctrl = { SSD1305_NOCONTINUE_BIT | SSD1305_CMD_BIT }; // Co = 1, D/C = 0
	while (HAL_OK != HAL_I2C_Mem_Write(&(SSD1305_I2C), SSD1305_ADDRESS, ctrl, I2C_MEMADD_SIZE_8BIT, &tmpcmd, 1, 1))
		;
}

void oled_commandList(uint8_t *c, uint8_t n) {
	while (HAL_OK != HAL_I2C_Master_Transmit(&(SSD1305_I2C), SSD1305_ADDRESS, c, n, 100))
		;
}

void oled_data(uint8_t* pData, uint16_t size) {
	uint8_t ctrl = SSD1305_NOCONTINUE_BIT | SSD1305_DATA_BIT; // Co = 0, D/C = 1
	while (HAL_OK != HAL_I2C_Mem_Write(&(SSD1305_I2C), SSD1305_ADDRESS, ctrl, I2C_MEMADD_SIZE_8BIT, pData, size, 200))
		;
}

// TODO: append control byte before data
//void oled_data_stream(const uint8_t d) {
//	uint8_t tmp[2] = {SSD1305_NOCONTINUE_BIT | SSD1305_DATA_BIT, d}; // Co = 0, D/C = 0
//	HAL_I2C_Master_Transmit(&(SSD1305_I2C), SSD1305_ADDR_WRITE, tmp, 2, 1);
//}

void ssd1305_Init(void) {
	// Init sequence, make sure its under 32 bytes, or split into multiples!
	uint8_t init_128x32[] = {
	// Init sequence for 128x32 OLED module
//			SSD1305_CONTINUE_BIT | SSD1305_CMD_BIT, // srt cmd, no cont data stream
//			SSD1305_DISPLAYOFF,          // 0xAE
//			SSD1305_SETDISPLAYCLOCKDIV, 0x80,          //0xA8,//0xF0,  10
//			SSD1305_SETMULTIPLEX, 0x3F,          //0x3F,               1f
//			SSD1305_SETDISPLAYOFFSET, 32,          //0x40,             00
//			SSD1305_SETSTARTLINE | 0x0,  // line #0
//			SSD1305_MEMORYMODE, 0x00,
//			SSD1305_SEGREMAP | 0x01,
//			SSD1305_COMSCANDEC,
//			SSD1305_SETCOMPINS, 0x12, 					// 0xDA, 0x12
//			SSD1305_SETCONTRAST, 0xCF, //0x32, 			// 0x81, 0x32  BF
//			SSD1305_SETPRECHARGE, 0xF1, //0xF1, 		// 0xd9, 0xF1  D2
//			SSD1305_SETVCOMLEVEL, 0x40,  //							   08
//
//			0x2E,
//			SSD1305_DISPLAYALLON_RESUME,
//			SSD1305_NORMALDISPLAY, 		// 0xA6
			0x80,
			0xae,
			0x80,
			0xd5,
			0x80,
			0xa0,
			0x80,
			0xa8,
			0x80,
			0x1f,
			0x80,
			0xd3,
			0x80,
			0x00,
			0x80,
			0xad,
			0x80,
			0x8e,
			0x80,
			0xd8,
			0x80,
			0x05,
			0x80,
			0xa1,
			0x80,
			0xC8,
			0x80,
			0xda,
			0x80,
			0x12,
			0x80,
			0x91,
			0x80,
			0x3f,
			0x80,
			0x3f,
			0x80,
			0x3f,
			0x80,
			0x3f,
			0x80,
			0x81,
			0x80,
			0x7f,
			0x80,
			0xd9,
			0x80,
			0xd2,
			0x80,
			0xdb,
			0x80,
			0x34,
			0x80,
			0xa6,
			0x80,
			0xa4,
			0x80,
			0xaf
			};


	oled_commandList(init_128x32, sizeof(init_128x32));

	HAL_Delay(100);                      		// 100ms delay recommended
	oled_command(SSD1305_DISPLAYON); 			// 0xaf

//	oled_command(SSD1305_DISPLAYALLON);

//  setContrast(0x2F);
	// fill
//	for (int i = 0; i < (132 * 32); i++)
//		oled_data(0xFF);
	//drawBitmap((SSD1305_HEIGHT - splash2_width) / 2, (SSD1305_HEIGHT - splash2_height) / 2, splash2_data, splash2_width, splash2_height, 1);
	Display_Picture(picture);
}

void Display_Picture(uint8_t* pic)
{
    uint8_t i,j=0;
    uint8_t pictmp[0x80];
	for(i=0;i<0x04;i++)
	{
	Set_Page_Address(i);
    Set_Column_Address(0x00);
        for(j=0;j<0x80;j++)
		{
        	pictmp[j] = pic[i*0x80+j];
		}
        oled_data(pictmp,0x80);
	}
//	const uint8_t sz = 132*64;
//	uint8_t tmp[sz];
//	for(int i = 0; i < sz; i++) {
//		tmp[i] = 0xff;
//	}
//		Set_Page_Address(0x00);
//	    Set_Column_Address(0x00);
//	oled_data(tmp,sz);
    return;
}

// Set page address 0~4
void Set_Page_Address(uint8_t add)
{	add=0xb0|add;
 	oled_command(add);
	return;
}

void Set_Column_Address(uint8_t add)
{	uint8_t tmp = (0x10|(add>>4));
	oled_command(tmp);
	tmp = (0x0f&add)|0x04;
	oled_command(tmp);
	return;
}




//void drawPixel(int16_t x, int16_t y, uint16_t color) {
//  if ((x >= 0) && (x < width()) && (y >= 0) && (y < height())) {
//    // Pixel is in-bounds. Rotate coordinates if needed.
////    switch (getRotation()) {
////    case 1:
////      grayoled_swap(x, y);
////      x = WIDTH - x - 1;
////      break;
////    case 2:
//      x = SSD1305_WIDTH - x - 1;
//      y = SSD1305_HEIGHT - y - 1;
////      break;
////    case 3:
////      grayoled_swap(x, y);
////      y = HEIGHT - y - 1;
////      break;
////    }
//
//    // adjust dirty window
////    window_x1 = min(window_x1, x);
////    window_y1 = min(window_y1, y);
////    window_x2 = max(window_x2, x);
////    window_y2 = max(window_y2, y);
//
////    if (_bpp == 1) {
////      switch (color) {
////      case MONOOLED_WHITE:
////        buffer[x + (y / 8) * WIDTH] |= (1 << (y & 7));
////        break;
////      case MONOOLED_BLACK:
////        buffer[x + (y / 8) * WIDTH] &= ~(1 << (y & 7));
////        break;
////      case MONOOLED_INVERSE:
////        buffer[x + (y / 8) * WIDTH] ^= (1 << (y & 7));
////        break;
////      }
////    }
////    if (_bpp == 4) {
//      uint8_t *pixelptr = &buffer[x / 2 + (y * WIDTH / 2)];
//      // Serial.printf("(%d, %d) -> offset %d\n", x, y, x/2 + (y * WIDTH / 2));
//      if (x % 2 == 0) { // even, left nibble
//        uint8_t t = pixelptr[0] & 0x0F;
//        t |= (color & 0xF) << 4;
//        pixelptr[0] = t;
//      } else { // odd, right lower nibble
//        uint8_t t = pixelptr[0] & 0xF0;
//        t |= color & 0xF;
//        pixelptr[0] = t;
//      }
////    }
//  }
//}

